# Tree_Cpp
여러 트리 자료구조를 C++로 구현하고 간단한 사용 예시를 담은 리포지토리입니다.

트리 자료구조들에 대한 개념은 "C와 C++로 구현하는 자료구조"[1] 책을 참고하였습니다.
다만 책에서는 직관적인 설명을 위하여 예제를 절차적 프로그래밍으로 구현하거나 구현 없이 개념 소개로 그치는 소재들이 있어, 이들을 C++에서 클래스로 직접 구현해 보고 그 시행착오를 공유하고자 레포지토리를 작성하게 되었습니다.  

## 예제 실행 방법
이 리포지토리는 Visual Studio 2022를 기준으로 작성되었습니다. Visual Studio가 설치되어있지 않다면 설치해주시길 바랍니다.

1. 리포지토리를 로컬 컴퓨터로 다운로드 받습니다.

2. 로컬의 리포지토리 디렉토리에 포함된 'Tree_Cpp.sln' 솔루션 파일을 더블 클릭합니다.

3. Visual Studio가 실행되고 우측에 '솔루션 탐색기' 바를 확인합니다.
(해당 '솔루션 탐색기'바가 없을시 상단의 '보기(V)'바에서 '솔루션 탐색기(P)'를 누르면 됩니다)

4. 해당 '솔루션 탐색기' 바에서 실행해보고 싶은 단원의 트리 프로젝트를 우클릭합니다.

5. 우클릭시 나오는 우클릭 메뉴에서 '시작 프로젝트로 설정'을 누르거나, 단축키 'A'를 누릅니다.

6. 디버깅 시작키인 'F5'를 눌러 예제를 실행합니다. 실행 결과가 검은 명렁 프롬프트에 출력될 것입니다.

## 목차  
[1. 재귀 호출을 이용한 이진 탐색 트리](#1-재귀-호출을-이용한-이진-탐색-트리)  
[2. 반복문을 이용한 이진 탐색 트리](#2-반복문을-이용한-이진-탐색-트리)  
[3. 힙](#3-힙)  
[4. 스플레이 트리](#4-스플레이-트리)  
[5. AVL 트리](#5-avl-트리)   
[6. 레드-블랙 트리](#6-레드-블랙-트리)   
[7. B-트리 (예정)](#7-b-트리)  



## 1. 재귀 호출을 이용한 이진 탐색 트리
이진 탐색 트리(Binary Search Tree, BST)는 각 노드의 키 값을 기준으로 대소 관계가 지켜지는 트리입니다. 부모노드의 키(key)는 좌측 자식 노드의 키보다는 크고, 우측 자식의 키보다는 작아야 하죠. 이 조건을 통해 효율적으로 특정 키의 노드를 찾을 수 있어, 평균적으로 O(log(n))의 시간 복잡도로 데이터의 삽입-검색-삭제를 할 수 있습니다[1].

이진 탐색 트리는 부모와 자식 간의 관계가 재귀적으로 반복되므로, 재귀적으로 구현하는 것이 편리합니다. 재귀는 함수 호출 기능을 활용해 이루어지는데, 호출 함수와 피호출 함수의 변수의 스코프를 격리하기 때문에 프로그래머가 여러 외부 영향을 고려하지 않고 직관적으로 문제를 해결할 수 있도록 합니다.





## 2. 반복문을 이용한 이진 탐색 트리
재귀는 프로그래머가 직관적으로 프로그래밍을 할 수 있도록 하지만, 재귀를 위한 반복적인 함수 호출에는 비용이 따릅니다.
호출 함수의 상태를 보존하기 위해 이들을 메모리의 스택에 저장하고, 또 함수 호출이 끝나면 이들을 레지스터로 다시 돌려놓는데 시간이 쓰이기 때문입니다.
수많은 데이터를 삽입-검색-삭제를 반복하는 자료구조에서는 이러한 재귀 호출의 비용이 치명적으로 다가옵니다.

따라서 자료구조의 효율성을 위해서는 편리한 재귀호출 대신, 직접 스택과 반복문을 사용해 필요한 상태 정보를 보존하고 또 복구하는 로직을 작성하는 것이 좋습니다[1].  



## 3. 힙
힙(heap)은 부모 노드와 자식 노드 사이에 대소 관계가 지켜지는 완전 이진 트리입니다.
부모가 자식보다 커야 한다면 max_heap이라 하고, 작아야 한다면 min_heap이라고 합니다.

max_heap만을 가정하면, 트리의 루트 노드는 모든 노드 중 가장 큰 키를 가진 노드이므로, 가장 키가 큰 요소를 반환하는 우선순위 큐로 활용할 수 있습니다. 또한 완전 이진 트리이므로 어레이 구조를 사용하여도 메모리 공간의 낭비가 크지 않으며, 간단한 인덱스 연산으로 부모와 자식 간 이동이 가능하다는 장점이 있습니다[1].




## 4. 스플레이 트리
특정 노드를 검색할 때마다 해당 노드를 루트에 가까운 노드에 올려, 자주 검색되는 노드가 더 빨리 검색되도록 하는 이진탐색트리의 일종입니다[1].





## 5. AVL 트리
이진 탐색 트리에서의 편향 문제를 해결한 균형 트리구조입니다.  

노드의 왼쪽 하위 트리의 높이와 우측 하위 트리의 높이의 차가 2 이상이 될 경우에, 해당 위치를 기준으로 회전을 적용해 트리의 균형을 조절합니다[1].




## 6. 레드-블랙 트리
완벽하게 균형이 지켜지는 2-3-4 트리의 개념을, 이진 탐색 트리에서 모방 구현한 균형 추종 트리입니다.  

2-3-4 트리는 기존에 한 개의 레코드가 들어가는 노드(2-노드) 외에도, 한 노드 안에 레코드가 2개 들어가는 노드(3-노드)와, 3개 들어가는 노드(4-노드)들을 함께 사용하여 삽입과 삭제에도 완벽하게 균형이 유지되도록 한 트리입니다.

레드-블랙 트리는 3-노드나 4-노드를 사용하지 않고, 2-노드에 '레드'와 '블랙'이라는 색깔 멤버 변수를 추가하여, 3-노드를 인접한 두 개의 2-노드로 구현하고, 4-노드를 인접한 3개의 2-노드로 구현합니다.
2-3-4 트리의 개념에서는 각각 하나의 노드인 3-노드와 4-노드가, 레드-블랙 트리에서는 높이를 가진 작은 트리와 같이 구현되기에, 레드-블랙 트리는 균형을 완벽하게 지키지는 못합니다.
그러나 2-3-4 트리의 개념을 추종하기에 균형을 어느 정도 지키고 있으며, 노드의 클래스 타입이 다를 수 있는 2-3-4 트리 개념을 그대로 구현하는 것보다는 이진 탐색 트리의 로직을 재활용해 비교적 쉽게 구현이 가능하다는 장점을 지닙니다[1].




## 7. B-트리
노드 내에 저장되는 데이터의 개수가 일반화된 다진 균형 트리구조입니다.



### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 참고문헌
[1] "C와 C++로 구현하는 자료구조" (주우석 저 / 한빛아카데미 출판)



