# Tree_Cpp
이진 탐색 트리부터 AVL 트리까지의 자료구조를 C++로 구현한 레포지토리입니다.

트리 자료구조들에 대한 개념은 "C와 C++로 구현하는 자료구조"[1] 책을 참고하였습니다.
다만 책에서는 직관적인 설명을 위하여 예제를 절차적 프로그래밍으로 구현하거나, 구현 없이 개념 소개로 그치는 소재들이 있어, 이들을 C++에서 클래스로 직접 구현해 보고 그 시행착오를 공유하고자 레포지토리를 작성하게 되었습니다.  



## 목차  
[1. 재귀 호출을 이용한 이진 탐색 트리](#1-재귀-호출을-이용한-이진-탐색-트리)  
[2. 반복문을 이용한 이진 탐색 트리](#2-반복문을-이용한-이진-탐색-트리)  
[3. 힙](#3-힙)  
[4. 스플레이 트리](#4-스플레이-트리)  
[5. AVL 트리](#5-avl-트리)   
[6. 레드-블랙 트리](#6-레드-블랙-트리)   
[7. B-트리 (예정)](#7-b-트리)  



## 1. 재귀 호출을 이용한 이진 탐색 트리
이진 탐색 트리(Binary Search Tree, BST)에서 부모노드의 키(key)는 좌측 자식 노드의 키보다는 크고, 우측 자식의 키보다는 작아야 합니다.
이 조건을 통해 효율적으로 특정 키의 노드를 찾을 수 있어, 평균적으로 O(log(n))의 시간 복잡도로 데이터의 삽입-검색-삭제를 할 수 있습니다[1].

이진 탐색 트리는 부모와 자식 간의 관계가 재귀적으로 반복되므로, 구현 또한 재귀적으로 작성하는 것이 편리합니다.
재귀의 근간이 되는 함수 호출은, 호출 함수와 피호출 함수의 변수들을 격리하기 때문에 프로그래머가 여러 외부 영향을 고려하지 않고 직관적으로 문제를 해결할 수 있도록 합니다.

### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 2. 반복문을 이용한 이진 탐색 트리
재귀는 프로그래머가 직관적으로 프로그래밍을 할 수 있도록 하지만, 재귀를 위한 반복적인 함수 호출에는 비용이 따릅니다.
호출 함수의 정보를 보호하기 위해 이들을 메모리의 스택에 저장하고, 또 함수 호출이 끝나면 이들을 레지스터로 다시 돌려놓는 시간이 필요하기 때문입니다. 
수많은 데이터를 삽입-검색-삭제를 반복하는 자료구조에서는 이러한 재귀 호출의 비용이 치명적으로 다가옵니다.

따라서 자료구조의 효율성을 위해서는 편리한 재귀호출 대신 꼭 필요한 정보만을 스택에 넣고 꺼내는 반복문으로 수동으로 짜는 것이 효율적입니다[1].  

### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 3. 힙
힙(heap)은 부모 노드가 자식 노드들보다 크거나(max_heap), 작은(min_heap) 완전 이진 트리입니다. 

트리의 루트 노드는 모든 노드 중 가장 크거나(max_heap), 작은(min_heap) 키를 가진 노드이므로, 가장 크거나 작은 요소를 반환해야 하는 우선순위 큐로 활용할 수 있습니다. 또한 완전 이진 트리이므로 어레이 구조를 사용하여도 메모리 공간의 낭비가 크지 않으며, 간단한 인덱스 연산으로 부모와 자식 간 이동이 가능하다는 장점이 있습니다[1].

### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 4. 스플레이 트리
특정 노드를 검색할 때마다 해당 노드를 루트에 가까운 노드에 올려, 자주 검색되는 노드가 더 빨리 검색되도록 하는 이진탐색트리의 일종입니다[1].

### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 5. AVL 트리
이진 탐색 트리에서의 편향 문제를 해결한 균형 트리구조입니다.  

노드의 왼쪽 하위 트리의 높이와 우측 하위 트리의 높이의 차가 2 이상이 될 경우에, 해당 위치를 기준으로 회전을 적용해 트리의 균형을 조절합니다[1].

### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 6. 레드-블랙 트리
완벽하게 균형이 지켜지는 2-3-4 트리의 개념을, 이진 탐색 트리로 모방 구현한 균형 추종 트리 구조입니다.  

2-3-4 트리는 기존에 한 개의 레코드가 들어가는 노드(2-노드) 외에도, 한 노드 안에 레코드가 2개 들어가는 노드(3-노드)와, 3개 들어가는 노드(4-노드)들을 함께 사용하여 삽입과 삭제에도 완벽하게 균형이 유지되도록 한 트리입니다.

레드-블랙 트리는  2-노드에 '레드'와 '블랙'이라는 색깔 멤버 변수를 추가하여, 3-노드를 인접한 두 개의 2-노드로 구현하고, 4-노드를 인접한 3개의 2-노드로 구현합니다.
2-3-4 트리의 개념에서는 각각 하나의 노드인 3-노드와 4-노드가, 레드-블랙 트리에서는 높이를 가진 작은 트리와 같이 구현되기에, 레드-블랙 트리는 균형을 완벽하게 지키지는 못합니다.
그러나 2-3-4 트리의 개념을 추종하기에 균형을 어느 정도 지키고 있으며, 노드의 클래스 타입이 다를 수 있는 2-3-4 트리 개념을 그대로 구현하는 것보다는 이진 탐색 트리의 로직을 재활용해 비교적 쉽게 구현이 가능합니다[1].

### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 7. B-트리
노드 내에 저장되는 데이터의 개수가 일반화된 다진 균형 트리구조입니다.

### 클래스 멤버 데이터 선언

### 클래스 멤버 함수 선언

### 주요 멤버 함수 구현



## 참고문헌
[1] "C와 C++로 구현하는 자료구조" (주우석 저 / 한빛아카데미 출판)



